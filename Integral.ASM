; Ахаладзе Мария, БПИ193
; Разработать программу численного интегрирования функции y=a+b*x3 (задаётся целыми числами а,b)
; в определённом диапазоне целых (задаётся так же) методом трапеций (шаг 1)

format PE console
entry start

include 'win32a.inc'

;--------------------------------------------------------------------------
section '.data' data readable writable

        stringA   db 'Input parameter a: ', 0
        stringB   db 'Input parameter b: ', 0

        stringLowerLimit db 'Input a lower integral limit: ', 0
        stringUpperLimit db 'Input an upper integral limit: ', 0

        stringScanningInteger   db '%d', 0
        stringOutput db 'Integral value: %d', 0

        stringInputError db 'Error, the input parameters must be between %d and %d, the program execution is completed', 10, 0
        stringLimitError db 'Error, an upper limit must be greater than a lower limit, the program execution is completed', 10, 0

        lowerLimit              dd 0            ; Нижний предел интегрирования
        upperLimit              dd 0            ; Верхний предел интегрирования

        loopCounter             dd 0            ; Счетчик цикла
        temp                    dd 0            ; Временная переменная для вычисления значения функции ax + bx^3

        sum                     dd 0            ; Сумма площадей трапеций
        limitSum                dd 0            ; Сумма значений функции ax + bx^3 в lowerLimit и upperLimit

        a                       dd 0            ; Параметр a функции
        b                       dd 0            ; Параметр b функции

        maxParameterValue       dd 1000         ; Максимально допустимое значение параметра
        minParameterValue       dd -1000        ; Минимально допустимое значение параметра

        maxLimitValue           dd 50           ; Максимально допустимое значение предела интегрирования
        minLimitValue           dd -50          ; Минимально допустимое значение предела интегрирования

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
section '.code' code readable executable

start:

        call ParameterAInput            ; Ввод параметра а

        call ParameterBInput            ; Ввод параметра b

        call LowerLimitInput            ; Ввод нижнего предела интегрирования

        call UpperLimitInput            ; Ввод верхнего предела интегрирования

        call CheckZero

        call IntegralCalculation        ; Вычисление значения интеграла

        push [sum]                      ; Вносим в стек значение интеграла
        push stringOutput               ; Вносим в стек строку, выводящую результат
        call [printf]                   ; Выводим значение интеграла

finish:                                 ; Метка окончания программы

        call [getch]
        push 0
        call [ExitProcess]

;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc ParameterAInput            ; Ввод параметра а

     push stringA               ; Вносим в стек строку, уведомляющую о вводе параметра а
     call [printf]              ; Выводим строку
     add esp, 4                 ; Удаление аргумента со стека

     push a                     ; Вносим в стек переменную-параметр а
     push stringScanningInteger ; Вносим в стек строку, в которую вводится значение а
     call [scanf]               ; Считываем значение
     add esp, 8                 ; Удаление аргументов со стека

     mov eax, [a]               ; Заносим значение а в регистр для проверки корректности значения
     call CheckParameterInput   ; Проверка корректности значения параметра, записанного в еах

ret

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc ParameterBInput            ; Ввод параметра b

     push stringB               ; Вносим в стек строку, уведомляющую о вводе параметра b
     call [printf]              ; Выводим строку
     add esp, 4                 ; Удаление аргумента со стека

     push b                     ; Вносим в стек переменную-параметр b
     push stringScanningInteger ; Вносим в стек строку, в которую вводится значение b
     call [scanf]               ; Считываем значение
     add esp, 8                 ; Удаление аргументов со стека

     mov eax, [b]               ; Заносим значение b в регистр для проверки корректности значения
     call CheckParameterInput   ; Проверка корректности значения параметра, записанного в еах

ret

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc LowerLimitInput             ; Ввод нижнего предела интегрирования

     push stringLowerLimit       ; Вносим в стек строку, уведомляющую о вводе нижнего предела интегрирования
     call [printf]               ; Выводим строку
     add esp, 4                  ; Удаление аргумента со стека

     push lowerLimit             ; Вносим в стек переменную-нижний предел интегрирования
     push stringScanningInteger  ; Вносим в стек строку, в которую вводится значение
     call [scanf]                ; Считываем значение
     add esp, 8                  ; Удаление аргументов со стека

     mov eax, [lowerLimit]       ; Заносим значение lowerLimit в регистр для проверки корректности значения
     call CheckLimitInput        ; Проверка корректности значения предела интегрирования, записанного в еах
ret

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc UpperLimitInput             ; Ввод верхнего предела интегрирования

     push stringUpperLimit       ; Вносим в стек строку, уведомляющую о вводе верхнего предела интегрирования
     call [printf]               ; Выводим строку
     add esp, 4                  ; Удаление аргумента со стека

     push upperLimit             ; Вносим в стек переменную-верхний предел интегрирования
     push stringScanningInteger  ; Вносим в стек строку, в которую вводится значение
     call [scanf]                ; Считываем значение
     add esp, 8                  ; Удаление аргументов со стека

     mov eax, [upperLimit]       ; Заносим значение upperLimit в регистр
     cmp eax, [lowerLimit]       ; Сравниваем еах со значением нижнего предела интегрирования
     jl Error                    ; Верхний предел интегрирования должен быть не меньше нижнего

     call CheckLimitInput        ; Проверка корректности значения предела интегрирования, записанного в еах
     ret

Error:

     push stringLimitError       ; Вносим в стек строку, уведомляющую об ошибке
     call [printf]               ; Выводим строку
     jmp finish                  ; Переходим к метке окончания программы

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc CheckParameterInput                ; Проверка, что введенное значение параметра находится в допустимом диапазоне

     cmp eax, [maxParameterValue]       ; Сравниваем еах с максимальным допустимым значением параметра
     jg ParameterValueError             ; Переход к метке об ошибке, если еах больше

     cmp eax, [minParameterValue]       ; Сравниваем еах с минимальным допустимым значением параметра
     jl ParameterValueError             ; Переход к метке об ошибке, если еах меньше

ret

ParameterValueError:

     push [maxParameterValue]           ; Помещаем в стек максимально допустимое значение параметра
     push [minParameterValue]           ; Помещаем в стек минимально допустимое значение парметра
     push stringInputError              ; Помещаем в стек строку, уведомляющую об ошибке
     call [printf]                      ; Выводим строку

     jmp finish                         ; Переходим к метке окончания программы

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc CheckLimitInput            ; Проверка, что введенное значения предела интегрирования находится в допустимом диапазоне

     cmp eax, [maxLimitValue]   ; Сравниваем еах с максимальным допустимым значением предела интегрирования
     jg LimitValueError         ; Переход к метке об ошибке, если еах больше

     cmp eax, [minLimitValue]   ; Сравниваем еах с минимальным допустимым значением предела интегрирования
     jl LimitValueError         ; Переход к метке об ошибке, если еах меньше

ret

LimitValueError:

     push [maxLimitValue]       ; Помещаем в стек максимально допустимое значение предела интегрирования
     push [minLimitValue]       ; Помещаем в стек минимально допустимое значение предела интегрирования
     push stringInputError      ; Помещаем в стек строку, уведомляющую об ошибке
     call [printf]              ; Выводим строку

     jmp finish                 ; Переходим к метке окончания программы

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc CheckZero                  ; Проверка частного случая, когда f(x) = 0

     mov eax, [a]               ; Заносим в стек значение параметра а
     cmp eax, 0                 ; Сравниваем с нулем
     jne exitCheck              ; Если равенство не выполняется, функция не имеет вид f(x) = 0

     mov eax, [b]               ; Заносим в стек значение параметра b
     cmp eax, 0                 ; Сравниваем с нулем
     jne exitCheck              ; Если равенство не выполняется, функция не имеет вид f(x) = 0

     push 0                     ; Функция имеет вид f(x) = 0, значит, интеграл равен нулю
     push stringOutput          ; Вносим в стек строку, выводящую результат
     call [printf]              ; Выводим значение интеграла

     jmp finish                 ; Переходим к метке окончания программы

exitCheck:
        ret
endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc FunctionValue           ; Вычисление значения функции ax + bx^3, где значение х записано в ebx

     mov [temp], ebx         ; Помещаем ebx в значение temp для того, чтобы корректно посчитать возведение в степень
     imul ebx, [temp]        ; Умножаем ebx на значение temp (получается значение выражения вида x * x)
     imul ebx, [temp]        ; Умножаем ebx на значение temp (получается значение выражения вида (x * x) * x)
     imul ebx, [b]           ; Умножаем ebx на значение параметра b (получается значение выражения вида b * x^3)
     add ebx, [a]            ; Складываем ebx со значением параметра a (получается значение выражения вида a + b * x^3)

ret

endp
;---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
proc IntegralCalculation        ; Вычисление значения интеграла методом трапеций

        mov ecx, [upperLimit]   ; Помещаем значние нижнего предела интегрирования в есх

        cmp ecx, [lowerLimit]   ; Сравниваем есх со значением верхнего предела интегрирования
        je exitCalculation      ; Если пределы интегрирования равны, то интеграл равен нулю и нет необходимости вычислять значение кодом ниже

        sub ecx, [lowerLimit]   ; Количество итераций вычислим как разность верхнего и нижнего пределов интегрирования,
        sub ecx, 1              ; после чего вычтем 1 (т.к. в цикле считаются значения функции строго внутри границ)
        cmp ecx, 0              ; Сравнение ecx с нулем
        je calculateLimitValues ; Если ecx = 0, то в цикле 0 итераций, нужно сразу перейти к вычислению значений функции в граничных точках

        mov ebx, [upperLimit]   ; Помещаем значение верхнего предела интегрирования в ebx, чтобы приравнять через него upperLimit и loopCounter
        mov [loopCounter], ebx

calculationLoop:                ; Цикл, в котором вычисляется сумма значений функции на промежутке (lowerLimit; upperLimit)

        xor ebx, ebx            ; Очистка ebx
        sub [loopCounter], 1    ; С каждой итерацией берем аргументом функции число, на 1 меньшее предыдущего (начиная с upperLimit - 1)
        mov ebx, [loopCounter]  ; Помещаем это значение в ebx

        call FunctionValue      ; Вызываем процедуру для вычисления значения функции, аргумент которой равен loopCounter, значение записывается в ebx
        add [sum], ebx          ; Прибавляем ebx к сумме площадей трапеций sum

loop  calculationLoop

calculateLimitValues:

        mov ebx, [lowerLimit]   ; Помещаем в ebx значение нижнего предела интегрирования
        call FunctionValue      ; Вызываем процедуру для вычисления значения функции, аргумент которой равен lowerLimit, значение записывается в ebx
        add [limitSum], ebx     ; Прибавляем ebx к сумме значений функции в граничных точках limitSum

        xor ebx, ebx

        mov ebx, [upperLimit]   ; Помещаем в ebx значение верхнего предела интегрирования
        call FunctionValue      ; Вызываем процедуру для вычисления значения функции, аргумент которой равен upperLimit, значение записывается в ebx
        add [limitSum], ebx     ; Прибавляем ebx к сумме значений функции в граничных точках limitSum

        xor edx, edx            ; Очищаем edx перед делением
        mov eax, [limitSum]     ; Помещаем значение limitSum в eax для деления
        mov ebx, 2              ; Помещаем в ebx 2, т.к. необходимо limitSum поделить на 2
        cdq                     ; Преобразовываем eax удвоением размера с помощью расширения старшего бита eax на edx
        idiv ebx                ; Делим на 2, результат хранится в eax

        add [sum], eax          ; Прибавляем eax к общей сумме значений функции


exitCalculation:                ; Выход из процедуры вычисления интеграла

ret

endp
;--------------------------------------------------------------------------
section '.idata' import data readable

    library kernel, 'kernel32.dll',\
            msvcrt, 'msvcrt.dll',\
            user32,'USER32.DLL'

    import kernel,\
           ExitProcess, 'ExitProcess'

    import msvcrt,\
           printf, 'printf',\
           scanf, 'scanf',\
           getch, '_getch'